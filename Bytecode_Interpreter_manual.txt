Addresses are always 16 bit (2 bytes) long, be it register addresses or memory addresses.
The numbers should be formatted as big-endian in binary.

--INSTRUCTION--
0 = STORE 
	FORMAT: (0) (DESTINATION MEMORY ADDR [0 - MAX MEMORY; 2 BYTES - 16-BIT UNSIGNED INT]) (REGISTER ADDR [0 - MAX REGISTER AMOUNT; 2 BYTES - 16-BIT UNSIGNED INT]) EX: STORE 10 15 - MOVES THE CONTENTS OF REGISTER 15 TO MEMORY ADDRESS 10
	PURPOSE: STORE VALUE FROM REGISTER ADDRESS INTO DESTINATION MEMORY ADDRESS.
	
	
1 = LOAD 
	FORMAT: (1) (DESTINATION REGISTER ADDR [0 - MAX REGISTER AMOUNT; 2 BYTES - 16-BIT UNSIGNED INT]) (MEMORY ADDR [0 - MAX MEMORY; 2 BYTES - 16-BIT UNSIGNED INT]) EX: LOAD 15 10 - MOVES THE CONTENTS OF MEMORY ADDRESS 10 TO REGISTER 15
	PURPOSE: LOAD VALUE FROM MEMORY ADDRESS INTO DESTINATION REGISTER.

2 = MOV	
	FORMAT: (2) (DESTINATION REGISTER ADDR [0 - MAX REGISTER AMOUNT; 2 BYTES - 16-BIT UNSIGNED INT]) (COPY REGISTER ADDR [0 - MAX REGISTER AMOUNT; 2 BYTES - 16-BIT UNSIGNED INT]) EX: MOV 14 15 - MOVES THE CONTENTS OF REGISTER 15 TO REGISTER 14
	PURPOSE: MOVES VALUE FROM COPY REGISTER TO DESTINATION REGISTER WITHOUT CHANGING COPY REGISTER CONTENTS.
	

3 = MOVI 
	FORMAT: (3) (DESTINATION REGISTER ADDR [0 - MAX REGISTER AMOUNT; 2 BYTES - 16-BIT UNSIGNED INT]) (CONSTANT VALUE - 4 BYTES - INT32_T) EX: MOV 14 150 - MOVES 150 TO REGISTER 14
	PURPOSE: MOVES CONSTANT INT32 TO DESTINATION REGISTER.

4 = MOVF 
	FORMAT: (4) (DESTINATION REGISTER ADDR [0 - MAX REGISTER AMOUNT; 2 BYTES - 16-BIT UNSIGNED INT]) (CONSTANT VALUE - 4 BYTES - 32-BIT FLOAT) EX: MOV 14 0.45 - MOVES 0.45 TO REGISTER 14
	PURPOSE: MOVES CONSTANT FLOAT TO DESTINATION REGISTER.

5 = ADD 
	FORMAT: (5) (REGISTER X ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Y ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Z ADDR [0 - MAX REGISTER AMOUNT])
	PURPOSE: ADD REGISTER X VALUE AND REGISTER Y VALUE AND STORE THE RESULT VALUE IN REGISTER Z.

6 = SUB 
	FORMAT: (6) (REGISTER X ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Y ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Z ADDR [0 - MAX REGISTER AMOUNT])
	PURPOSE: SUBTRACT REGISTER Y VALUE FROM REGISTER X VALUE AND STORE THE RESULT VALUE IN REGISTER Z.


7 = MUL
	FORMAT: (7) (REGISTER X ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Y ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Z ADDR [0 - MAX REGISTER AMOUNT])
	PURPOSE: MULTIPLY REGISTER X VALUE AND REGISTER Y VALUE AND STORE THE RESULT VALUE IN REGISTER Z.

8 = DIV 
	FORMAT: (8) (REGISTER X ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Y ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Z ADDR [0 - MAX REGISTER AMOUNT])
	PURPOSE: DIVIDE REGISTER X VALUE BY REGISTER Y VALUE AND STORE THE RESULT VALUE IN REGISTER Z.

9 = CMP
	FORMAT: (9) (CONDITION) (REGISTER X ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Y ADDR [0 - MAX REGISTER AMOUNT]) (REGISTER Z ADDR [0 - MAX REGISTER AMOUNT])
	PURPOSE: COMPARE REGISTER X VALUE WITH REGISTER Y VALUE AND RETURNS TRUE VALUE IF THE QUESTIONED CONDITION IS TRUE IN REGISTER Z.

	CONDITION (1 BYTE):
		0: NUMBER 1 LESS THAN NUMBER 2
		1: NUMBER 1 GREATER THAN NUMBER 2
		2: NUMBER 1 EQUAL TO NUMBER 2
		3: NUMBER 1 DIFFERENT THAN NUMBER 2
		4: NUMBER 1 GREATER OR EQUAL TO NUMBER 2
		5: NUMBER 1 LESS OR EQUAL TO NUMBER 2

	REGISTER X ADDR (2 BYTES):
	- ANY REGISTER 

	REGISTER Y ADDR (2 BYTES):
	- ANY REGISTER

	RESULT STORE REGISTER ADDR (2 BYTES):
	- ANY REGISTER

10 = JMP 
	FORMAT: (10) (BYTECODE PROGRAM JUMP ADDR - [32-BIT UNSIGNED INT])
	PURPOSE: INCONDITIONALLY JUMPS TO BYTECODE PROGRAM ADDR.

11 = JMPZ
	FORMAT: (11) (REGISTER X ADDR [0 - MAX REGISTER AMOUNT]) (BYTECODE PROGRAM JUMP ADDR - [32-BIT UNSIGNED INT])
	PURPOSE: JUMPS TO BYTECODE PROGRAM ADDR IF VALUE AT REGISTER X IS ZERO.

12 = JMPNZ
	FORMAT: (12) (REGISTER X ADDR [0 - MAX REGISTER AMOUNT]) (BYTECODE PROGRAM JUMP ADDR - [32-BIT UNSIGNED INT])
	PURPOSE: JUMPS TO BYTECODE PROGRAM ADDR IF VALUE AT REGISTER X IS NOT ZERO.

13 = DRWBUFF
	FORMAT: (13) 
	PURPOSE: DRAWS THE GRAPHICS BUFFER.

14 = DRWPXL //keep in mind the graphics buffer resolution is 320x240, so pixel address can be from 0 to 76799
	FORMAT: (14) (REGISTER X ADDR - [16-BIT UNSIGNED INT]) (REGISTER Y ADDR - [16-BIT UNSIGNED INT])
	PURPOSE: COLORS THE PIXEL AT THE PIXEL ADDR IN REGISTER X WITH THE VALUE AT REGISTER Y WHICH CAN BE FROM 0 to 255 SINCE THE VIDEO COLOR IS 8 BIT.

15 = KBRX
	FORMAT: (15) (REGISTER X ADDR - [16-BIT UNSIGNED INT]) (REGISTER Y ADDR - [16-BIT UNSIGNED INT])
	PURPOSE: IF KB_RX.processed IS FALSE, COPY KB_RX.key TO REGISTER X THEN SET NEW KEY FLAG TO 1 AT REGISTER Y ADDRESS. THEN SET KB_RX.processed TO TRUE. EVERY TIME A KEY IS PRESSED, KB_RX.processed is = TRUE. 
	*In your code, when using this instruction, you should set the NEW KEY FLAG back to 0 manually at the selected NEW KEY FLAG register after processing the key press to create a coherent KEYBOARD read loop.
	 For example: after using KBRX, if the NEW KEY FLAG is 1 at the selected register, do XYZ action, then set the NEW KEY FLAG back to 0 at the selected register to prepare it for another read then use KBRX again or do something 	 else.

16 = HALT
	FORMAT: (16) 
	PURPOSE: STOPS EXECUTION

17 = DRWLN
	FORMAT: (17) (POINT 1 X REGISTER ADDR) (POINT 1 Y REGISTER ADDR) (POINT 2 X REGISTER ADDR) (POINT 2 Y REGISTER ADDR) (LINE COLOR REG ADDR) (LINE THICKNESS REG ADDR)
	PURPOSE: DRAWS LINE

	

	


	


